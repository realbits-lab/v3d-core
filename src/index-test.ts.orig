import "@babylonjs/core/Loading/loadingScreen";

// Register plugins (side effect)
import "@babylonjs/core/Loading/Plugins/babylonFileLoader";
import "@babylonjs/core/Materials";
import "@babylonjs/loaders/glTF/glTFFileLoader";

// Debug
import "@babylonjs/core/Debug";
import "@babylonjs/gui";
import "@babylonjs/inspector";
const debug = false;
const shadow_debug = false;
const spheres = false;

import { Scene } from "@babylonjs/core/scene";
import { Engine } from "@babylonjs/core/Engines/engine";
import { Color3, Vector3 } from "@babylonjs/core/Maths/math";
import { ShadowGenerator } from "@babylonjs/core/Lights/Shadows/shadowGenerator";

import { DirectionalLight } from "@babylonjs/core/Lights/directionalLight";
import { HemisphericLight } from "@babylonjs/core/Lights/hemisphericLight";
import { PointLight } from "@babylonjs/core/Lights/pointLight";
import { SphereBuilder } from "@babylonjs/core/Meshes/Builders/sphereBuilder";
import { TorusKnotBuilder } from "@babylonjs/core/Meshes/Builders/torusKnotBuilder";
// import {MToonMaterial} from "./shader/babylon-mtoon-material/src";
import { Texture } from "@babylonjs/core/Materials/Textures/texture";
import { Material } from "@babylonjs/core/Materials/material";
import { VertexBuffer } from "@babylonjs/core/Buffers/buffer";
import { VRMManager } from "./importer/babylon-vrm-loader/src";
import { SceneLoader } from "@babylonjs/core/Loading/sceneLoader";
import { ArcRotateCamera } from "@babylonjs/core/Cameras/arcRotateCamera";
import { Mesh } from "@babylonjs/core/Meshes/mesh";
// import { V3DCore } from "./index";
import "@babylonjs/core/Helpers/sceneHelpers";
import "@babylonjs/core/Meshes/Builders/sphereBuilder";
import "@babylonjs/core/Meshes/Builders/torusKnotBuilder";
import "@babylonjs/inspector";
import "./importer/babylon-vrm-loader/src/index";

// Init BabylonJS Engine
// const canvas = document.getElementById("renderCanvas") as HTMLCanvasElement;
// let engine: Engine;
// if (Engine.isSupported()) {
//   engine = new Engine(canvas, true);
// }

// const fileInput = document.getElementById("select-file") as HTMLInputElement;

window.onload = async (e) => {
  console.log("Onload");
  //   const vrmFile = "testfiles/7822444336497004526.vrm";
  //   const vrmFile = "testfiles/default.vrm";

  const debugProperties = getDebugProperties();
  const canvas = document.getElementById("renderCanvas") as HTMLCanvasElement;
  const engine = new Engine(canvas, true, {
    alpha: false,
    disableWebGL2Support: debugProperties.webgl1,
  });

  //   const v3DCore = new V3DCore(engine, new Scene(engine));

  const scene = new Scene(engine);
  const camera = new ArcRotateCamera(
    "MainCamera1",
    0,
    0,
    3,
    new Vector3(0, 1.2, 0),
    scene,
    true
  );
  camera.lowerRadiusLimit = 0.1;
  camera.upperRadiusLimit = 20;
  camera.wheelDeltaPercentage = 0.01;
  camera.minZ = 0.3;
  camera.position = new Vector3(0, 1.2, -3);
  camera.attachControl(canvas, true);

  scene.createDefaultEnvironment({
    createGround: true,
    createSkybox: false,
    enableGroundMirror: false,
    enableGroundShadow: false,
  });

  // Lights
  const directionalLight = new DirectionalLight(
    "DirectionalLight1",
    new Vector3(0, -0.5, 1.0),
    scene
  );
  directionalLight.position = new Vector3(0, 25, -50);
  directionalLight.setEnabled(true);
  const hemisphericLight = new HemisphericLight(
    "HemisphericLight1",
    new Vector3(-0.2, -0.8, -1),
    scene
  );
  hemisphericLight.setEnabled(false);
  const pointLight = new PointLight("PointLight1", new Vector3(0, 0, 1), scene);
  pointLight.setEnabled(false);

  // Meshes
  const standardMaterialSphere = Mesh.CreateSphere(
    "StandardMaterialSphere1",
    16,
    1,
    scene
  );
  standardMaterialSphere.position = new Vector3(1.5, 1.2, 0);
  standardMaterialSphere.receiveShadows = true;

  const shadowCaster = Mesh.CreateTorusKnot(
    "ShadowCaster",
    1,
    0.2,
    32,
    32,
    2,
    3,
    scene
  );
  shadowCaster.position = new Vector3(0.0, 5.0, -10.0);
  shadowCaster.setEnabled(debugProperties.shadow);
  if (debugProperties.shadow) {
    const shadowGenerator = new ShadowGenerator(1024, directionalLight);
    shadowGenerator.addShadowCaster(shadowCaster);
  }

  if (debugProperties.inspector) {
    await scene.debugLayer.show({
      globalRoot: document.getElementById("wrapper") as HTMLElement,
    });
  }

  // Expose current scene
  (window as any).currentScene = scene;

  scene.onBeforeRenderObservable.add(() => {
    // SpringBone
    if (!scene.metadata || !scene.metadata.vrmManagers) {
      return;
    }
    const managers = scene.metadata.vrmManagers as VRMManager[];
    const deltaTime = scene.getEngine().getDeltaTime();
    managers.forEach((manager) => {
      manager.update(deltaTime);
    });
  });
  engine.runRenderLoop(() => {
    scene.render();
    shadowCaster.rotate(Vector3.Up(), 0.01);
  });
  window.addEventListener("resize", () => {
    engine.resize();
  });
  await SceneLoader.AppendAsync(
    // "./testfiles/",
    "./",
    // "default.vrm",
    // "7822444336497004526.vrm",
    "AliciaSolid.vrm",
    scene
  );

  let fileCount = 1;
  (document.getElementById("file-input") as HTMLInputElement).addEventListener(
    "change",
    (evt) => {
      const file = (evt as any).target.files[0];
      console.log(`loads ${file.name} ${file.size} bytes`);
      const currentMeshCount = scene.meshes.length;
      SceneLoader.Append("file:", file, scene, () => {
        console.log(`loaded ${file.name}`);
        for (let i = currentMeshCount; i < scene.meshes.length; i++) {
          scene.meshes[i].translate(Vector3.Right(), 1.5 * fileCount);
          scene.meshes[i].receiveShadows = true;
        }
        fileCount++;
      });
    }
  );
};

interface DebugProperties {
  webgl1: boolean;
  shadow: boolean;
  inspector: boolean;
}

function getDebugProperties(): DebugProperties {
  const href = window.location.href;

  return {
    webgl1: href.includes("webgl1"),
    shadow: href.includes("shadow"),
    inspector: href.includes("inspector"),
  };
}

// window.onload = async (e) => {
async function main() {
  console.log("Onload");
  //   const vrmFile = "testfiles/7822444336497004526.vrm";
  //   const vrmFile = "testfiles/default.vrm";
  const vrmFile = "testfiles/1.vrm";

  // Create v3d core
  const v3DCore = new V3DCore(engine, new Scene(engine));
  v3DCore.transparentBackground();
  await v3DCore.AppendAsync("", vrmFile);

  // Get managers
  const vrmManager = v3DCore.getVRMManagerByURI(vrmFile);
  console.log("Printing loaded VRM file metadata: ", vrmManager.ext.meta);

  // Camera
  v3DCore.attachCameraTo(vrmManager);

  // Lights
  v3DCore.addAmbientLight(new Color3(1, 1, 1));

  // Lock camera target
  v3DCore.scene.onBeforeRenderObservable.add(() => {
    vrmManager.cameras[0].setTarget(vrmManager.rootMesh.getAbsolutePosition());
  });

  // Render loop
  engine.runRenderLoop(() => {
    v3DCore.scene.render();
  });

  // Model Transformation
  vrmManager.rootMesh.translate(new Vector3(1, 0, 0), 1);
  vrmManager.rootMesh.rotation = new Vector3(0, 135, 0);

  // Work with HumanoidBone
  vrmManager.humanoidBone.leftUpperArm.addRotation(0, -0.5, 0);
  vrmManager.humanoidBone.head.addRotation(0.1, 0, 0);

  // Work with BlendShape(MorphTarget)
  vrmManager.morphing("Joy", 1.0);
}

export {};
